"""
This is an implementation of the mutual transition method: Tracking the Evolution of Community Structures in Time-Evolving Social Networks [Tajeuna et al. 2015]
"""

# Libraries
import time

import numpy as np
from sklearn.cluster import KMeans

import datapreparation.preprocess as pp
import datapreparation.utils as ut
import scores.scores as sc


def similarity_measure(vec1, vec2):
    """
    this function calculates the similarity mesure between
    two vectors (from normalized burt matrix of two clusters
    it calculates the harmonic mean of both vectors
    :param vec1: normalized burt vector of cluster 1
    :param vec2: normalized burt vector of cluster 2
    :return: harmonic mean
    """

    sum = 0.0
    for k in range(len(vec1)):
        den = vec1[k] + vec2[k]
        if den > 0:
            num = vec1[k] * vec2[k]
            sum += (2 * num / den)

    return sum


def jaccard_measure(i, j):
    """
    calculates the jaccard index for two different clusters
    it uses the burt matrix which contains info about the number of shared nodes
    between two clusters
    :param i: index of cluster 1
    :param j: index of cluster 2
    :return: jaccard index
    """
    return (pp.burt_matrix[i][j] / (pp.burt_matrix[i][i] + pp.burt_matrix[j][j] - pp.burt_matrix[i][j]))


def fill_similarity_and_jaccard(trans_matrix, jaccard_matrix):
    """
    loops through all clusters and calculates the similarity value and the jaccard index for
    every pair
    :param burt: burt matrix holding the number of shared nodes between a pair of clusters
    :param burt_norm: normalized burt matrix
    :param trans_matrix: matrix holding the list of all similarities between every pair of clusters
    :param jaccard_matrix: matrix holding the list of all jaccard indexes between every pair of clusters
    :return:
    """
    for i in range(0, len(pp.burt_matrix)):
        for j in range(0, len(pp.burt_matrix)):
            trans_matrix[i][j] = similarity_measure(pp.burt_norm[i], pp.burt_norm[j])
            jaccard_matrix[i][j] = jaccard_measure(i, j)


def mixture_gaussians(m1, m2, std1, std2):
    """
    find the intersection points of two gaussians
    :param m1: mean of first curve
    :param m2: mean of second curve
    :param std1: standard deviation of first curve
    :param std2: standard deviation of second curve
    :return: intersection point
    """
    a = 1 / (2 * std1 ** 2) - 1 / (2 * std2 ** 2)
    b = m2 / (std2 ** 2) - m1 / (std1 ** 2)
    c = m1 ** 2 / (2 * std1 ** 2) - m2 ** 2 / (2 * std2 ** 2) - np.log(std2 / std1)
    for threshold_value in np.roots([a, b, c]):
        # consider only the points that are between 0 and 1
        if threshold_value >= 0 and threshold_value <= 1:
            return threshold_value


def get_threshold(trans_matrix):
    """
    calculates the similarity threshold according to all the similarities calculated
    in the mutual transition matrix (that contains the similarity value between a pair of clusters)
    :return: threshold
    """

    # transform the mutual transition matrix into a sorted list
    trans_list = sorted(trans_matrix.flatten())
    trans_list = [[i] for i in trans_list if i != 0]
    # apply K means on the list of similarity values to divide them into 2 categories
    clusters = KMeans(n_clusters=2, random_state=0).fit(trans_list)
    trans_list0 = []
    trans_list1 = []

    for index in range(0, len(trans_list)):
        if clusters.labels_[index] == 0:
            trans_list0.append(trans_list[index][0])
        else:
            trans_list1.append(trans_list[index][0])

    std0 = np.std(trans_list0)
    std1 = np.std(trans_list1)
    m0 = np.mean(trans_list0)
    m1 = np.mean(trans_list1)

    # The threshold is the intersection of the curve of both lists of values generated by K means
    return mixture_gaussians(m0, m1, std0, std1)


def apply_mutual_transition():
    """
    this function applies the mutual transition on a time sequence
    note that the data has to be preprocessed first in order to generate the burt_matrix
    :param data_directory: the path of the directory where the data exists
    """

    start = time.time()

    trans_matrix = np.zeros([len(pp.burt_matrix), len(pp.burt_matrix)])
    jaccard_matrix = np.zeros([len(pp.burt_matrix), len(pp.burt_matrix)])

    # fill similarity matrix and jaccard matrix
    fill_similarity_and_jaccard(trans_matrix, jaccard_matrix)

    # deduce the threshold from the mutual transition values
    threshold = get_threshold(trans_matrix)

    # get the list of sequences for the clusters evolution
    predicted_sequences = get_sequences(trans_matrix, jaccard_matrix, threshold)

    end = time.time()

    print("========================================")
    print("          MUTUAL TRANSITION             ")
    print("========================================")

    print("\n Threshold:", threshold)

    print("\n done in : ", ut.get_elapsed(start, end))

    sc.get_scores("MUTUAL TRANSITION", predicted_sequences)


def get_sequences(trans_matrix, jaccard_matrix, threshold):
    """
    this function generates the sequences of the clusters
    it considers a cluster belongs to the same sequence of another cluster
    if the similarity value and the jaccard index of both clusters is larger than the similarity
    threshold
    :param trans_matrix: matrix holding the list of all similarities between every pair of clusters
    :param jaccard_matrix: matrix holding the list of all jaccard indexes between every pair of clusters
    :return: list of sequences of clusters
    """

    all_sequences = []
    for timestep in range(pp.number_timesteps):
        clusters = pp.get_clusters_in_timestep(timestep)
        for cluster in clusters:
            if form(cluster, jaccard_matrix, threshold) == True:
                all_sequences.append([cluster])

    for sequence in all_sequences:
        timestep = pp.get_cluster_timestep(sequence[0]) + 1
        while timestep <= pp.number_timesteps:
            last_timestep_in_sequence = pp.get_cluster_timestep(sequence[-1])
            for cluster1 in pp.get_sequence_clusters_in_timestep(sequence, last_timestep_in_sequence):
                temp = {}
                for cluster2 in pp.get_clusters_in_timestep(timestep):
                    try:
                        if jaccard_matrix[cluster1, cluster2] > threshold and trans_matrix[
                            sequence[0], cluster2] > threshold:
                            sequence.append(cluster2)
                    except:
                        pass
            timestep = timestep + 1
    final_sequences = []
    used_clusters = []
    for sequence in all_sequences:
        temp = []
        for cluster in sequence:
            if cluster not in temp and cluster not in used_clusters:
                temp.append(cluster)
                used_clusters.append(cluster)
        if temp not in final_sequences:
            final_sequences.append(temp)

    for cluster in range(pp.number_clusters):
        cluster_found = False
        for sequence in final_sequences:
            if cluster in sequence:
                cluster_found = True
                break
        if cluster_found == False:
            final_sequences.append([cluster])
    return final_sequences


def form(cluster, jaccard_matrix, threshold):
    """This function checks if the cluster will form a new sequence"""
    is_new_sequence = False
    timestep = pp.get_cluster_timestep(cluster)
    previous_timesteps = 0
    if timestep == 0:
        is_new_sequence = True
    else:
        stop = False
        while previous_timesteps < timestep:
            other_clusters = pp.get_clusters_in_timestep(previous_timesteps)
            for other_cluster in other_clusters:
                try:
                    if jaccard_matrix[other_cluster, cluster] > threshold:
                        stop = True
                        break
                except:
                    pass
            if stop == True:
                break
            else:
                previous_timesteps = previous_timesteps + 1
        if stop == False:
            is_new_sequence = True
    return is_new_sequence
